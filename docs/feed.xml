<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/adventures/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/adventures/" rel="alternate" type="text/html" /><updated>2018-09-11T14:29:41+02:00</updated><id>http://localhost:4000/adventures/</id><title type="html">Adventures</title><subtitle>Tales of a knowledge traveller.</subtitle><entry><title type="html">Adventures in Coq</title><link href="http://localhost:4000/adventures/something/2018/09/07/adventures_in_coq.html" rel="alternate" type="text/html" title="Adventures in Coq" /><published>2018-09-07T08:00:00+02:00</published><updated>2018-09-07T08:00:00+02:00</updated><id>http://localhost:4000/adventures/something/2018/09/07/adventures_in_coq</id><content type="html" xml:base="http://localhost:4000/adventures/something/2018/09/07/adventures_in_coq.html">&lt;p&gt;&lt;a href=&quot;https://coq.inria.fr/&quot;&gt;Coq&lt;/a&gt; is a formal proof and verification system, which allow to proof mathematical statements and certify programs against a specification.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://coq.inria.fr/documentation&quot;&gt;documentation section&lt;/a&gt; has a link to &lt;a href=&quot;https://softwarefoundations.cis.upenn.edu/&quot;&gt;Software Foundations&lt;/a&gt;, a 4-Volumes work about functional programming, theorem proving, operational semantics, Hoare logic, type systems, specification and verification.&lt;/p&gt;

&lt;p&gt;The topic of this adventure is to explore this work.&lt;/p&gt;

&lt;p&gt;Reproducing selected parts of the work offers little value. We also do not give any solution to the exercises. Instead, we try to address the needs of the following kind of readers.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Readers who started reading and left in the middle a quite long time ago. These readers want to have their memory refreshed.&lt;/li&gt;
  &lt;li&gt;Readers who already know about Coq. These readers want to know what they will find without spending hours sifting through the tedious parts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other goals are the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Summarize all the coq features introduced in the course, and say whether they are explained in detail or merely alluded too.&lt;/li&gt;
  &lt;li&gt;Summarize the core ideas.&lt;/li&gt;
  &lt;li&gt;Introduce some personal derived work inspired from the course.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;complete-outline&quot;&gt;Complete outline&lt;/h2&gt;

&lt;p&gt;Here’s the complete outline of the whole thing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Volume 1: Logical Foundations
    &lt;ul&gt;
      &lt;li&gt;Preface&lt;/li&gt;
      &lt;li&gt;Functional Programming in Coq&lt;/li&gt;
      &lt;li&gt;Proof by Induction&lt;/li&gt;
      &lt;li&gt;Working with Structured Data&lt;/li&gt;
      &lt;li&gt;Polymorphism and Higher-Order Functions&lt;/li&gt;
      &lt;li&gt;More Basic Tactics&lt;/li&gt;
      &lt;li&gt;Logic in Coq&lt;/li&gt;
      &lt;li&gt;Inductively Defined Propositions&lt;/li&gt;
      &lt;li&gt;Total and Partial Maps&lt;/li&gt;
      &lt;li&gt;The Curry-Howard Correspondence&lt;/li&gt;
      &lt;li&gt;Induction Principles&lt;/li&gt;
      &lt;li&gt;Properties of Relations&lt;/li&gt;
      &lt;li&gt;Simple Imperative Programs&lt;/li&gt;
      &lt;li&gt;Lexing and Parsing in Coq&lt;/li&gt;
      &lt;li&gt;An Evaluation Function for Imp&lt;/li&gt;
      &lt;li&gt;Extracting ML from Coq&lt;/li&gt;
      &lt;li&gt;More Automation&lt;/li&gt;
      &lt;li&gt;Postscript&lt;/li&gt;
      &lt;li&gt;Bibliography&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 2: Programming Language Foundations
    &lt;ul&gt;
      &lt;li&gt;Preface&lt;/li&gt;
      &lt;li&gt;Program Equivalence&lt;/li&gt;
      &lt;li&gt;Hoare Logic, Part I&lt;/li&gt;
      &lt;li&gt;Hoare Logic, Part II&lt;/li&gt;
      &lt;li&gt;Hoare Logic as a Logic&lt;/li&gt;
      &lt;li&gt;Small-step Operational Semantics&lt;/li&gt;
      &lt;li&gt;Type Systems&lt;/li&gt;
      &lt;li&gt;The Simply Typed Lambda-Calculus&lt;/li&gt;
      &lt;li&gt;Properties of STLC&lt;/li&gt;
      &lt;li&gt;More on the Simply Typed Lambda-Calculus&lt;/li&gt;
      &lt;li&gt;Subtyping&lt;/li&gt;
      &lt;li&gt;A Typechecker for STLC&lt;/li&gt;
      &lt;li&gt;Adding Records to STLC&lt;/li&gt;
      &lt;li&gt;Typing Mutable References&lt;/li&gt;
      &lt;li&gt;Subtyping with Records&lt;/li&gt;
      &lt;li&gt;Normalization of STLC&lt;/li&gt;
      &lt;li&gt;A Collection of Handy General-Purpose Tactics&lt;/li&gt;
      &lt;li&gt;Tactic Library for Coq: A Gentle Introduction&lt;/li&gt;
      &lt;li&gt;Theory and Practice of Automation in Coq Proofs&lt;/li&gt;
      &lt;li&gt;Partial Evaluation&lt;/li&gt;
      &lt;li&gt;Postscript&lt;/li&gt;
      &lt;li&gt;Bibliography&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 3: Verified Functional Algorithms
    &lt;ul&gt;
      &lt;li&gt;Preface&lt;/li&gt;
      &lt;li&gt;Basic Techniques for Permutations and Ordering&lt;/li&gt;
      &lt;li&gt;Insertion Sort&lt;/li&gt;
      &lt;li&gt;Insertion Sort With Multisets&lt;/li&gt;
      &lt;li&gt;Selection Sort, With Specification and Proof of Correctness&lt;/li&gt;
      &lt;li&gt;Binary Search Trees&lt;/li&gt;
      &lt;li&gt;Abstract Data Types&lt;/li&gt;
      &lt;li&gt;Running Coq programs in ML&lt;/li&gt;
      &lt;li&gt;Implementation and Proof of Red-Black Trees&lt;/li&gt;
      &lt;li&gt;Number Representations and Efficient Lookup Tables&lt;/li&gt;
      &lt;li&gt;Priority Queues&lt;/li&gt;
      &lt;li&gt;Binomial Queues&lt;/li&gt;
      &lt;li&gt;Programming with Decision Procedures&lt;/li&gt;
      &lt;li&gt;Graph Coloring&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume 4: QuickChick: Property-Based Testing in Coq
    &lt;ul&gt;
      &lt;li&gt;Preface&lt;/li&gt;
      &lt;li&gt;Introduction&lt;/li&gt;
      &lt;li&gt;A Tutorial on Typeclasses in Coq&lt;/li&gt;
      &lt;li&gt;Core QuickChick&lt;/li&gt;
      &lt;li&gt;Case Study: a Typed Imperative Language&lt;/li&gt;
      &lt;li&gt;The QuickChick Command-Line Tool&lt;/li&gt;
      &lt;li&gt;QuickChick Reference Manual&lt;/li&gt;
      &lt;li&gt;PostScript&lt;/li&gt;
      &lt;li&gt;Bibliography&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;volume-1--preface&quot;&gt;Volume 1 : Preface&lt;/h2&gt;

&lt;p&gt;Like other formal softwares such as Mathematica, Maxima or Sage, Coq features the ability of converting the raw Coq scripts into nice documentation artefacts.&lt;/p&gt;

&lt;p&gt;We provide a minimalist example of how to do that in &lt;a href=&quot;https://github.com/xavierdpt/adventures/tree/master/trove/SF1Preface/nice&quot;&gt;the trove&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Software Foundations is about Coq in particular, and automated theorems in general. Such tools include SAT solvers, SMT solvers and model checkers.&lt;/p&gt;

&lt;p&gt;Beside Coq, other interactive proof assistants include Isabelle, Twelf, ACL2 and PVS.&lt;/p&gt;

&lt;p&gt;The coq system includes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a proof-checker&lt;/li&gt;
  &lt;li&gt;a large library of common definitions and lemmas&lt;/li&gt;
  &lt;li&gt;tactics for constructing complex proofs semi-automatically&lt;/li&gt;
  &lt;li&gt;a special-purpose programming language for defining new tactics called LTac&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Coq has been used to&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;To check the security of the JavaCard platform&lt;/li&gt;
  &lt;li&gt;Formal specifications of the x86 and LLVM instruction sets&lt;/li&gt;
  &lt;li&gt;Formal specifications of the C programming languages and others.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Coq has been used to build:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CompCert, a fully-verified optimizing compiler for C&lt;/li&gt;
  &lt;li&gt;CertiKos, a fully verified hypervisor&lt;/li&gt;
  &lt;li&gt;Proving the correctness of subtle algorithms involving floating point numbers&lt;/li&gt;
  &lt;li&gt;CertiCrypt, an environment for reasoning about the security of cryptographic algorithms&lt;/li&gt;
  &lt;li&gt;verified implementations of the open-source RISC-V processor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Ynot system embeds “relational Hoare reasoning” in Coq.&lt;/p&gt;

&lt;p&gt;Coq has been used to develop the first formally verified proof of the 4-color theorem.&lt;/p&gt;

&lt;p&gt;Coq has been used to formalize a proof the Feit-Thompson Theorem, which is the first major step in the classification of finite simple groups.&lt;/p&gt;

&lt;p&gt;Beside coq, other functional programming languages include Haskell, OCaml, Standard ML, F#, Scala, Scheme, Racket, Common Lisp, Clojure and Erlang.&lt;/p&gt;

&lt;p&gt;Functional programming is well-suited to formal methods, because pure functions have no side effects, which make them easier to reason with and parallelize.&lt;/p&gt;

&lt;p&gt;Two Coq IDEs are Proof General for Emacs and CoqIDE.&lt;/p&gt;

&lt;h2 id=&quot;v1-basics&quot;&gt;V1 Basics&lt;/h2&gt;

&lt;p&gt;In this part, the reader will learn about:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Coq’s functional programming language is called Gallina.&lt;/li&gt;
  &lt;li&gt;basic data types such as booleans, integers and strings are defined in Gallina and are parts of Coq’s standard library.&lt;/li&gt;
  &lt;li&gt;simple &lt;code class=&quot;highlighter-rouge&quot;&gt;Inductive&lt;/code&gt; types&lt;/li&gt;
  &lt;li&gt;inductive type with constructors that have arguments&lt;/li&gt;
  &lt;li&gt;how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Definition&lt;/code&gt; and pattern matching to define functions on inductive types and inductyve type with constructors that have arguments&lt;/li&gt;
  &lt;li&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; placeholder to avoid introducing too many names&lt;/li&gt;
  &lt;li&gt;how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Compute&lt;/code&gt; to perform evaluation by simplification&lt;/li&gt;
  &lt;li&gt;how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Example&lt;/code&gt; for defining unit tests and proving them beginning with &lt;code class=&quot;highlighter-rouge&quot;&gt;Proof&lt;/code&gt; and terminating with &lt;code class=&quot;highlighter-rouge&quot;&gt;Qed&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Admitted&lt;/code&gt; to leave things unproven.&lt;/li&gt;
  &lt;li&gt;how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Check&lt;/code&gt; to investigate the type of things.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The reader will meet:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;simpl&lt;/code&gt; tactic for simplification&lt;/li&gt;
  &lt;li&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;reflexivity&lt;/code&gt; tactic for equalities&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;End&lt;/code&gt; commands for defining modules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Things that will be alluded to include:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the possibility of extracting a function to OCaml, Haskell, or Scheme&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, negation &lt;code class=&quot;highlighter-rouge&quot;&gt;negb&lt;/code&gt;, conjunction &lt;code class=&quot;highlighter-rouge&quot;&gt;andb&lt;/code&gt;, disjunction &lt;code class=&quot;highlighter-rouge&quot;&gt;orb&lt;/code&gt; from the Coq library will be redefined.&lt;/p&gt;

&lt;p&gt;The book make heavy usages of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Notation&lt;/code&gt; command, which is can be quite cryptic for beginners.&lt;/p&gt;

&lt;p&gt;The natural integers &lt;code class=&quot;highlighter-rouge&quot;&gt;nat&lt;/code&gt; and their constructors &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; will be redefined.&lt;/p&gt;

&lt;p&gt;A predecessor function which illustrates pattern matching on integers will be introduced.&lt;/p&gt;

&lt;p&gt;A more elaborate function which returns a number minus 2 will be introduced.&lt;/p&gt;

&lt;p&gt;A recursive function which tests for evenness will be introduced, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;Fixpoint&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;Addition, multiplication, subtraction and exponentiation will be redefined with recursive functions.&lt;/p&gt;

&lt;p&gt;The reader will learn that arguments of a same type can be grouped together, i.e. the type of the arguments need only be declared once.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reflexivity&lt;/code&gt; does more than &lt;code class=&quot;highlighter-rouge&quot;&gt;simpl&lt;/code&gt; because it expands the terms in a such a way that would leave the expression tree difficult to use, while &lt;code class=&quot;highlighter-rouge&quot;&gt;simpl&lt;/code&gt; leaves things cleaner.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Theorem&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Example&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Lemma&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Fact&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Remark&lt;/code&gt; are internally synonymous.&lt;/p&gt;

&lt;p&gt;Here’s something interesting.&lt;/p&gt;

&lt;p&gt;First, we define a function on answers, but do not specify its body.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Definition foo (a:answer) : answer.
Admitted.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then, despite the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; function is not specified, we can prove a theorem involving &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Theorem thm : forall n m:answer, n=m -&amp;gt; foo n = foo m.
intros n m.
intro eq.
rewrite -&amp;gt; eq.
reflexivity.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is so because &lt;code class=&quot;highlighter-rouge&quot;&gt;reflexivity&lt;/code&gt; works whenever the trees on the left and on the right of the equality are the same.&lt;/p&gt;

&lt;p&gt;Note on &lt;code class=&quot;highlighter-rouge&quot;&gt;rewrite&lt;/code&gt;: the arrow points to which side of the equality wins.&lt;/p&gt;

&lt;p&gt;To perform case analysis on inductive types, use &lt;code class=&quot;highlighter-rouge&quot;&gt;destruct&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make proof readables, use bullets such as &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; and braces &lt;code class=&quot;highlighter-rouge&quot;&gt;{...}&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;v1-proof-by-induction&quot;&gt;V1 Proof by Induction&lt;/h2&gt;

&lt;p&gt;To make the following work:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;From X Require Export Y.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Execute the following command first:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;coqc Y.v&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When simplification + reflexivity does not work, try case analysis (&lt;code class=&quot;highlighter-rouge&quot;&gt;destruct&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;When case analysis does not work, try proof by induction (&lt;code class=&quot;highlighter-rouge&quot;&gt;induction&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; can be use to prove things using the variables of the main proof. &lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt; is useful because it is closure-aware.&lt;/p&gt;

&lt;h2 id=&quot;v1-working-with-structured-data&quot;&gt;V1 Working with Structured Data&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Stopped here.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Pairs of numbers&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Coq defines types, function and notations for definining pairs and extracting the first and second element of the pair.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;List of numbers&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A list is either the empty list &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt; or a an element and another list (&lt;code class=&quot;highlighter-rouge&quot;&gt;cons&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Coq define types, functions and notations for working with lists. &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; is the empty list, &lt;code class=&quot;highlighter-rouge&quot;&gt;x::l&lt;/code&gt; adds an element to a list, and &lt;code class=&quot;highlighter-rouge&quot;&gt;[x;...;z]&lt;/code&gt; define a list inline.&lt;/p&gt;

&lt;p&gt;Common things to do with lists is to repeat them, get their length, append to a list, get the head or get the tail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Reasoning about lists&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Prove that reversing a list does not change its length.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quest idea&lt;/strong&gt;: Convert a Coq proof to a hiearchical informal proof, so that the levels of details can be expanded at will depending on the familiarity level or something.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Search&lt;/code&gt; can be used to search theorems according to shape.&lt;/p&gt;

&lt;p&gt;With ProofGeneral, use C-c C-a C-a to seach, then C-c C-; to copy/paste the result.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Options&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Options define a &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; constructor with no value and a &lt;code class=&quot;highlighter-rouge&quot;&gt;Some&lt;/code&gt; constructor with a value.&lt;/p&gt;

&lt;p&gt;In Coq, any inductive type with two constructors support the &lt;code class=&quot;highlighter-rouge&quot;&gt;if ... then ... else ...&lt;/code&gt; construct.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Partial Maps&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Define an inductive type for identifiers, and an equality test for identifiers.&lt;/p&gt;

&lt;p&gt;Then a partial map is either the empty map, or an identifier with a value and another (smaller ?) partial map.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; function overrides one value.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt; function scan the map for a supplied identifier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quest idea&lt;/strong&gt;: How can the find function be made smarter, i.e. with better than linear complexity?&lt;/p&gt;

&lt;h2 id=&quot;v1-polymorphisms-and-higher-order-functions&quot;&gt;V1 Polymorphisms and Higher-Order Functions&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Polymorphism&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Compare&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Inductive list : Type :=
  | nil : list
  | cons : nat → list → list.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Inductive list (X:Type) : Type :=
  | nil : list X
  | cons : X → list X → list X.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Coq performs some type inference so that it is rarely necessary to express type arguments.&lt;/p&gt;

&lt;p&gt;Another keyword is “unification”.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Arguments&lt;/code&gt; command specifies which arguments to treat implicitely in curly braces.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Arguments nil {X}.
Arguments cons {X} _ _.
Arguments repeat {X} x count.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Arguments can also be declared as impicity by specifying the implicity with curly braces in the definition itself. Then the arguments are implicity in the body of the definition too.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Inductive list {X:Type} : Type :=
  | nil : list
  | cons : X → list → list.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Prefixing a term with &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; expose all the arguments defined implicity, for situation where type inference fails.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Functions as data&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The syntax &lt;code class=&quot;highlighter-rouge&quot;&gt;fun ... =&amp;gt; ...&lt;/code&gt; defines a function inline.&lt;/p&gt;

&lt;p&gt;Functionals include &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fold&lt;/code&gt;…&lt;/p&gt;

&lt;p&gt;Functions can return other functions.&lt;/p&gt;

&lt;h2 id=&quot;v1-more-basic-tactics&quot;&gt;V1 More Basic Tactics&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt; works when the conclusion of something match the goal exactly, and leaves the hypotheses of the something as new goals.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apply Thm with (x:=y)&lt;/code&gt; is useful when the theorem needs something it cannot guess.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apply Thm with y&lt;/code&gt; works when Coq can figure out where to put the supplied value on its own.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;symetry&lt;/code&gt; is useful to rewrite an equality from right to left.&lt;/p&gt;

&lt;p&gt;The constructors of inductive types are injective, and if a value is an instance of some constructor, then it’s an instance of no other constructors of that type.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;inversion&lt;/code&gt; tactics exploit these facts.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inversion&lt;/code&gt; detects things that cannot work and solve the goals immediately for these cases.&lt;/p&gt;

&lt;p&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; is hypothesis &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Thm&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;A-&amp;gt;B&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;apply Thm in H&lt;/code&gt; produces a hypothesis which matches &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;symmetry in H&lt;/code&gt; applies the &lt;code class=&quot;highlighter-rouge&quot;&gt;symetry&lt;/code&gt; tactics on hypothesis &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When a variable is introduced, it is understood that some particular value of this variable is being considered. When using &lt;code class=&quot;highlighter-rouge&quot;&gt;induction&lt;/code&gt;, pay attention to which variables are in the context.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;generalize dependent n&lt;/code&gt; reverts the effect of &lt;code class=&quot;highlighter-rouge&quot;&gt;intro&lt;/code&gt; for some particular variable.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unfold f&lt;/code&gt; unfolds the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;destruct&lt;/code&gt; can perform case analysis on the result of any computation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;destruct (plus n 1)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Adding &lt;code class=&quot;highlighter-rouge&quot;&gt;eqn&lt;/code&gt; saves the equality of each cases.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;destruct (plus n 1) eqn:E&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;v1-logic-in-coq&quot;&gt;V1 Logic in Coq&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Prop&lt;/code&gt; is the type of propositions.&lt;/p&gt;

&lt;p&gt;Conjunction &lt;code class=&quot;highlighter-rouge&quot;&gt;/\&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;split&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;desctruct&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Applying a projection thereom on a conjunction helps to keep only the part we’re intersted in.&lt;/p&gt;

&lt;p&gt;Disjunction &lt;code class=&quot;highlighter-rouge&quot;&gt;\/&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Negation &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;exfalso&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This command&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Require Import Coq.Setoids.Setoid.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;allows &lt;code class=&quot;highlighter-rouge&quot;&gt;rewrite&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;reflexivity&lt;/code&gt; to exploit &lt;code class=&quot;highlighter-rouge&quot;&gt;iff&lt;/code&gt; statements efficiently.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exist&lt;/code&gt; performs an implicit destruction with introductions.&lt;/p&gt;

&lt;p&gt;The tactic &lt;code class=&quot;highlighter-rouge&quot;&gt;exist (witness)&lt;/code&gt; provides a witness to an existential.&lt;/p&gt;

&lt;p&gt;The proposition which states that some element is in a list is a recursive proposition which can be defined with &lt;code class=&quot;highlighter-rouge&quot;&gt;Fixpoint&lt;/code&gt; and pattern matching.&lt;/p&gt;

&lt;p&gt;Another possibility is to define proposition inductively.&lt;/p&gt;

&lt;h2 id=&quot;v1-the-curry-howard-correspondance&quot;&gt;V1 The Curry Howard Correspondance&lt;/h2&gt;

&lt;p&gt;A proof is a program that proves a given type exists.&lt;/p&gt;

&lt;p&gt;A program is a proof that something of the type of the program exists.&lt;/p&gt;

&lt;p&gt;When doing proofs, the focus is on the type, and the exact evidence supplied to prove the type does not really matter.&lt;/p&gt;

&lt;p&gt;When writing programs, the focus is on the evidence, and the type of it does not really matter.&lt;/p&gt;

&lt;p&gt;For instance, when proving that a function from nat to nat exists &lt;code class=&quot;highlighter-rouge&quot;&gt;nat -&amp;gt; nat&lt;/code&gt;, any function will do, but we are usually interested in particular functions from nat to nat, and on their properties.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quest Idea&lt;/strong&gt;: What would it mean to think about the properties of a proof of something ? Is to possible to make two different proofs, and prove that one of the proof has a property that the other has not ?&lt;/p&gt;

&lt;p&gt;Proofs are programs that manipulate evidence.&lt;/p&gt;

&lt;p&gt;It’s possible to write proof objects directly, without a proof script.&lt;/p&gt;

&lt;p&gt;Here’s an example:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Definition HYP (P Q : Prop) : Prop := (P-&amp;gt;Q) /\ P.

Definition THM := forall (P Q : Prop), (HYP P Q) -&amp;gt; Q.

Theorem thm_proof : THM.
intros p q.
intro conj.
destruct conj as [imp pp].
apply imp.
apply pp.
Qed.

Definition hypfun P Q : Prop hyp : HYP P Q : Q :=
match hyp with
| conj imp pp =&amp;gt; imp pp
end.

Definition thmfun : THM := hypfun&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this example, we first define the hypothesis &lt;code class=&quot;highlighter-rouge&quot;&gt;HYP&lt;/code&gt; and the theorem’s assertion &lt;code class=&quot;highlighter-rouge&quot;&gt;THM&lt;/code&gt;, which asserts that &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt; can be derived from the hypothesis. Then we prove the theorem.&lt;/p&gt;

&lt;p&gt;What follows is an attempt to rewrite nicely the output of &lt;code class=&quot;highlighter-rouge&quot;&gt;Print thm_proof&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The function &lt;code class=&quot;highlighter-rouge&quot;&gt;hypfun&lt;/code&gt; produces &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt; from the hypothesis. It simply pattern match on the conjunction to extract both sides, and apply the left side to the right side. Since the right side is something of type &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;, and the left side produces something of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt; from something of type &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;, the result is what is produced by the right side, which is of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then &lt;code class=&quot;highlighter-rouge&quot;&gt;thmfun&lt;/code&gt; simply uses &lt;code class=&quot;highlighter-rouge&quot;&gt;hypfun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This shows that using destruct is equilalent to pattern matching, and apply hypothesese is equivalent to applying functions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Proof Scripts&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The command &lt;code class=&quot;highlighter-rouge&quot;&gt;Show Proof.&lt;/code&gt; can show the proof script in the middle of the proof process.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Programming with tactics&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here are three functions on natural defined with tactics. One is the identity, the other is the constant 0, and the third is the successor function.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Definition identity_nat : nat -&amp;gt; nat.
intro n.
apply n.
Qed.

Definition zero_nat : nat -&amp;gt; nat.
intro n.
apply O.
Qed.

Definition successor_nat : nat -&amp;gt; nat.
intro n.
apply S.
apply n.
Qed.

Print identity_nat.
Print zero_nat.
Print successor_nat.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Quest Idea&lt;/strong&gt;: Describe tactics by their proof script.&lt;/p&gt;

&lt;h2 id=&quot;v1-induction-principles&quot;&gt;V1 Induction Principles&lt;/h2&gt;

&lt;p&gt;Every recursive type comes with a &lt;code class=&quot;highlighter-rouge&quot;&gt;_ind&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;_rect&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;v1-simple-imperative-programs&quot;&gt;V1 Simple Imperative Programs&lt;/h2&gt;

&lt;p&gt;Tacticals &lt;code class=&quot;highlighter-rouge&quot;&gt;try&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; (simple and general form), &lt;code class=&quot;highlighter-rouge&quot;&gt;repeat&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Tactic Notation&lt;/code&gt;, LTac primitives, OCaml API&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;omega&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;Require Import Coq.omega.Omega&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clear&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;subst&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;rename&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;assumption&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;contradiction&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Reserved Notation&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In large Coq developments it is common to see a definition given in both functional and relational styles, plus a lemma stating that the two coincide, allowing further proofs to switch from one point of view to the other at will.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quest Idea&lt;/strong&gt;: Change the point of view in some “large” development.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Coercion&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Bind Scope&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Infix&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Open Scope&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The imperative language being defined allow infinite loops, but Coq does not allow potentially infinite recursions.&lt;/p&gt;

&lt;p&gt;To solve this, evaluation must be defined as a relation. Then every programs must be proven to evaluate to the corresponding results, infinite recursions will correspond to  infinite proofs, but all attempts at finite computations are on the user’s shoulder, i.e. Coq itself will never attempt to perform a computation that may be infinite.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--preface&quot;&gt;Volume 2 : Preface&lt;/h2&gt;

&lt;p&gt;Topics : operational semantics, Hoare logic, static type systems&lt;/p&gt;

&lt;p&gt;reasoning about the properties of specific programs&lt;/p&gt;

&lt;p&gt;reasoning about the properties of programming languages&lt;/p&gt;

&lt;p&gt;representing programs as mathematical objects&lt;/p&gt;

&lt;p&gt;abstract syntax&lt;/p&gt;

&lt;p&gt;big-step and small-step styles&lt;/p&gt;

&lt;p&gt;equivalence of programs&lt;/p&gt;

&lt;p&gt;correctness of metaprograms, such as compilers and optimizers&lt;/p&gt;

&lt;p&gt;Hoare triples : pre-condition and post-conditions&lt;/p&gt;

&lt;p&gt;type systems are part of lightweight formal methods = modest power, but efficient, and embeddable in compilers, linkers, analyzers&lt;/p&gt;

&lt;p&gt;model checkers, contract checkers, run-time monitoring techniques&lt;/p&gt;

&lt;p&gt;simply-typed lambda calculus&lt;/p&gt;

&lt;h2 id=&quot;volume-2--program-equivalence&quot;&gt;Volume 2 : Program Equivalence&lt;/h2&gt;

&lt;p&gt;Arithmetic and boolean expressions are equivalence when they evaluate to the same values.&lt;/p&gt;

&lt;p&gt;Two commands are equivalent if one command terminates on some state if and only iff the other does.&lt;/p&gt;

&lt;p&gt;Example: Skipping can be removed.&lt;/p&gt;

&lt;p&gt;Example: Skipping can be added.&lt;/p&gt;

&lt;p&gt;Example: Conditional with &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; can be optimized out.&lt;/p&gt;

&lt;p&gt;Example: Conditional which evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; can be optimized out.&lt;/p&gt;

&lt;p&gt;Example: Conditionals can be swapped when the condition is negated.&lt;/p&gt;

&lt;p&gt;Similar theorems apply to while loops.&lt;/p&gt;

&lt;p&gt;Example : When the guard is equivalent to true, the while loop never terminates.&lt;/p&gt;

&lt;p&gt;Example : Loop unrolling&lt;/p&gt;

&lt;p&gt;The three relations defined (arithmetic, boolean, commands) are equivalence relations.&lt;/p&gt;

&lt;p&gt;Congruences properties must be proved for every constructor (i.e. CIf, CSeq, …)&lt;/p&gt;

&lt;p&gt;Definition of sound program transformation.&lt;/p&gt;

&lt;p&gt;Constant folding is a sound transformation.&lt;/p&gt;

&lt;p&gt;One source of nondeterminism is variables initialized with arbitrary values.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--hoare-logic-part-i&quot;&gt;Volume 2 : Hoare Logic Part I&lt;/h2&gt;

&lt;p&gt;In volume 1, a small programming language was defined, with abstract syntax trees and an evaluation relation which specifies operational semantics.&lt;/p&gt;

&lt;p&gt;Properties which were proven include determinism of evaluation, equivalence of functional and relational definitions of arithmetic expression evaluation, guaranteed termination of some programs, correctness of some program transformations, and behavioral equivalence.&lt;/p&gt;

&lt;p&gt;Goal of this part is to carry some program verification with Floyd-Hoare Logic.&lt;/p&gt;

&lt;p&gt;Floyd-Hoare logic combines a natural way of writing down specifications with a compositional proof technique for proving program correctness.&lt;/p&gt;

&lt;p&gt;Assertions.&lt;/p&gt;

&lt;p&gt;An Hoare triple (Pre-condition ; command ; Post-condition) specifies that when command is called on a state satisfying the precondition and terminates, then it must satisfy the post condition.&lt;/p&gt;

&lt;p&gt;Hoare triples for assignment.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;eapply&lt;/code&gt; tactic applies a theorem and replace all the premises that it failed to unify with existential variables.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;eassumption&lt;/code&gt; works like &lt;code class=&quot;highlighter-rouge&quot;&gt;assumption&lt;/code&gt;, but tries to use existential variables.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--hoare-logic-part-ii&quot;&gt;Volume 2 : Hoare Logic Part II&lt;/h2&gt;
&lt;p&gt;Once the outermost precondition and postcondition are chosen, the only creative part in verifying programs using Hoare Logic is finding the right loop invariants.&lt;/p&gt;

&lt;p&gt;Weakest preconditions.&lt;/p&gt;

&lt;p&gt;Checking the validity of decorated programs can mostly be automated.&lt;/p&gt;

&lt;p&gt;Decorated commands.&lt;/p&gt;

&lt;p&gt;Extraction function which removes the assertions.&lt;/p&gt;

&lt;p&gt;Annotated program to proof assertion with function that recursively extracts everything to be proved in a big conjunction.&lt;/p&gt;

&lt;p&gt;Custom &lt;code class=&quot;highlighter-rouge&quot;&gt;verify&lt;/code&gt; tactic defined in LTac&lt;/p&gt;

&lt;h2 id=&quot;volume-2--hoare-as-a-logic&quot;&gt;Volume 2 : Hoare as a Logic&lt;/h2&gt;

&lt;p&gt;The presentation of Hoare logic was model-theoretic.&lt;/p&gt;

&lt;p&gt;Another way is to define a set of axioms and inference rules which talk about commands and Hoare triples, but it’s more verbose.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--small-step-operational-semantics&quot;&gt;Volume 2 : Small-Step Operational Semantics&lt;/h2&gt;

&lt;p&gt;What was done was big-step semantics, called natural semantics by Gilles Kahn.&lt;/p&gt;

&lt;p&gt;This style is not very well suited to concurrent programming languages.&lt;/p&gt;

&lt;p&gt;Also, supporting undefined behavior requires using Inductive propositions rather than fixpoints.&lt;/p&gt;

&lt;p&gt;Now, a command may fail for two different reasons : infinite loop or undefined behavior.&lt;/p&gt;

&lt;p&gt;What is desirable is to allow infinite loops but prevent undefined behavior.&lt;/p&gt;

&lt;p&gt;Toy language with only constants and addition, with a big-step style evaluator, defined by a Fixpoint and an Inductive relation.&lt;/p&gt;

&lt;p&gt;Then the small-step evaluation relation is exposed.&lt;/p&gt;

&lt;p&gt;Parenthesis on relations : binary relations, deterministic relation, custom tactic.&lt;/p&gt;

&lt;p&gt;Strong progress, normal forms.&lt;/p&gt;

&lt;p&gt;Multi-step reduction relation.&lt;/p&gt;

&lt;p&gt;Proof that the big step and small step definitions define the same thing.&lt;/p&gt;

&lt;p&gt;Small-step version of the Imp language.&lt;/p&gt;

&lt;p&gt;Additional command in Imp which launches computations in parallel.&lt;/p&gt;

&lt;p&gt;Proof that some example program can terminate with any values.&lt;/p&gt;

&lt;p&gt;Small step stack machine.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--types&quot;&gt;Volume 2 : Types&lt;/h2&gt;

&lt;p&gt;Type preservation and progress&lt;/p&gt;

&lt;p&gt;Another toy language.&lt;/p&gt;

&lt;p&gt;Single-step relation.&lt;/p&gt;

&lt;p&gt;Strong progress theorem fails for this language.&lt;/p&gt;

&lt;p&gt;Typing relation.&lt;/p&gt;

&lt;p&gt;Well-typed terms make progress.&lt;/p&gt;

&lt;p&gt;The result of well-typed terms are well typed.&lt;/p&gt;

&lt;p&gt;Because of progress and preservation, well-typed terms are sound.&lt;/p&gt;

&lt;p&gt;More custom tactics.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--the-simply-typed-lambda-calculus&quot;&gt;Volume 2 : The Simply Typed Lambda-Calculus&lt;/h2&gt;

&lt;p&gt;STLC = Simply Typed Lambda-Calculus&lt;/p&gt;

&lt;p&gt;STLC embodies functional abstraction&lt;/p&gt;

&lt;p&gt;Variable binding and substitution.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--properties-of-stlc&quot;&gt;Volume 2 : Properties of STLC&lt;/h2&gt;

&lt;p&gt;Type safety theorem, canonical forms, progress theorem, preseration theorem, substitution lemma, context invariance, free variables.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--more-on-the-simply-typed-lambda-calculus&quot;&gt;Volume 2 : More on the Simply Typed Lambda-Calculus&lt;/h2&gt;

&lt;p&gt;Numbers, let bindings, pairs, units, sums, lists, general recursion, records.&lt;/p&gt;

&lt;p&gt;Coq hackery to make extensions to &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;Hint Extern&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;volume-2--subtyping&quot;&gt;Volume 2 : Subtyping&lt;/h2&gt;

&lt;p&gt;Persons and students&lt;/p&gt;

&lt;h2 id=&quot;volume-2--a-typechecker-for-stlc&quot;&gt;Volume 2 : A Typechecker for STLC&lt;/h2&gt;

&lt;p&gt;Todo : Records, References, RecordSub, Norm, LibTactics, UseTactics, UseAuto, PE&lt;/p&gt;</content><author><name></name></author><summary type="html">Coq is a formal proof and verification system, which allow to proof mathematical statements and certify programs against a specification.</summary></entry></feed>